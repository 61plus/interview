# 项目相关

<!-- TOC -->

- [1. 基于Android和Java的流式二维码数据传输系统](#1-基于android和java的流式二维码数据传输系统)
  - [1.1. 简介](#11-简介)
  - [1.2. 应用和优点](#12-应用和优点)
  - [1.3. 传输效率](#13-传输效率)
  - [1.4. 研究贡献](#14-研究贡献)
    - [1.4.1. 第一阶段](#141-第一阶段)
    - [1.4.2. 第二阶段](#142-第二阶段)
  - [1.5. 开发APP遇到的问题](#15-开发app遇到的问题)
    - [1.5.1. 不能实时解码](#151-不能实时解码)
    - [1.5.2. 代码扩展性差](#152-代码扩展性差)

<!-- /TOC -->

## 1. 基于Android和Java的流式二维码数据传输系统

### 1.1. 简介

流式二维码数据传输系统，以动态二维码的形式在手机／电脑之间传送文件。发送端可以是手机、电脑等任意有屏幕的设备，接收端是带有摄像头的手机。发送端将文件数据编码后嵌入到多个二维码中，二维码动态显式于电脑／手机屏幕上。接收端APP通过摄像头连续捕捉发送的二维码，识别并解码还原出数据，完成文件传输过程。

### 1.2. 应用和优点

- 目前手机之间需要传送小文件（如照片）需要蓝牙或wifi进行配对连接，然后传输文件，这样有两个弊端：需要设备硬件支持，需要提前配对连接。而这种基于二维码的传输不需要硬件支持（手机几乎全都有摄像头），运行于软件层面上；且不需要提前建立连接，即用即传。
- 目前将文件从台式电脑传送到手机需要通过USB有线连接，或手机加入与台式机在同一局域网的wifi网络，这样很不方便。而通过基于二维码的传输只需要将二维码在电脑屏幕上显示，手机打开摄像头拍摄即可完成文件传输。
- 一些如企业等有保密需求的环境下，手机不能连接wifi加入同一局域网，通过基于二维码的传输则可方便解决。

### 1.3. 传输效率

在发送方最高为30fps的环境下，我们设计的黑白二维码可以达到200kbps，彩色（4色）二维码可以达到300kbps，应用机器学习后可以达到380kbps。

1080P每帧的处理时间在20ms左右。边界检测6ms，小方块采样8ms，识别2ms，纠错2ms。

### 1.4. 研究贡献

两个阶段

#### 1.4.1. 第一阶段

- 新的二维码布局：不同于一个小方块一种颜色，ShiftCode可以在小方块内部嵌套了一个更小的方块，以小方块的移动方向来嵌入数据。优点：嵌入数据更多，可扩展，为解决帧重叠问题提供可能。
- 解决帧重叠问题：对于30fps的接收方，当发送方帧速率超过15fps时就会出现帧重叠的问题。采用前后两帧相同位置小方块前景色和后景色相反的设计，可以在小方块发生帧重叠时正确区分前后帧小方块的移动方向，从而将重叠帧分离开。
- 可靠性解决方案：对于每一帧的数据，使用Reed-Solomon纠错编码，其优点是可以对连续出错有较好的纠错能力。对所有发送的帧数据使用RaptorQ冗余编码，因为这种传输是单向传输，并没有丢帧重传机制，RaptorQ可以将原始的N帧数据计算生成(N + K)帧数据，只要接收到任意的N帧即可还原出原数据。

#### 1.4.2. 第二阶段

- 基于机器学习的通用动态二维码识别方案：对于任何现有的基于规则的动态二维码方案，都可以将其识别步骤替换为机器学习方案，识别效率和准确度上都有很大提升。
- 统一的识别框架：只需要将小方块采样点颜色和其对应的真实数据交给机器学习训练，得到机器学习模型，后续真正传输时只需要采样小方块，交给模型即可得到真实数据。
- 解决帧重叠问题：以黑白为例，重叠帧中小方块可能有4个状态：【黑+黑】、【黑+白】、【白+黑】和【白+白】，通过人为制造【黑+黑】、【黑+白】、【白+黑】和【白+白】这4个状态，接下就只需要确定小方块属于其中哪个状态。这实际是一个分类问题，只需要提前训练好状态的分类，即可判断出小方块的重叠情况。更细节的需要涉及到rolling shutter现象。

### 1.5. 开发APP遇到的问题

#### 1.5.1. 不能实时解码

问题：接收端为30fps，即一秒钟要处理30张图片，每一张图片总的（边界检测、采样、识别、纠错）处理时间要在33ms内。前期没有专门优化导致每帧处理时间需要1秒以上。

解决方法：

- 使用Android Device Monitor的TraceView工具分析每一帧的处理耗时分布，找到耗时最长的函数进行优化，如此循环。
- 因Android提供的帧数据是NV21格式，最初是将图片由NV21转换为RGB，非常耗时。最初尝试将转换函数的浮点运算转换为整数运算，效果不好；之后尝试使用OpenGL ES的shader，即GPU来进行转换运算，有一定效果但耗时仍长；再尝试使用JNI即C++来运算，仍未达到预期。再后来转变思路，因为不会用到图片中所有像素点，所以可以在需要时再当场对单个像素点转换，这样暂时解决了问题。但后来发现因为采样点还是比较多，总体来看转换函数耗时还是很大，最后项目整体由RGB转到YUV，不再需要颜色转换，问题顺利解决。
- 二维码边界检测是使用一个小矩形逐渐放大直到框住二维码，这个过程需要逐像素行检查和扩展，很耗时。考虑到传输过程中摄像头不会大幅度移动，即二维码相对图片中的位置较为稳定，那么框住的矩形也会较为稳定，这样在确定一个矩形后，对于下一帧，只需要将矩形缩小1/3或1/5即可，节约了很多计算。
- 边界检测的结果是定位到二维码的四个顶点，最初是根据这四个顶点通过反透视变换生成一个标准的二维码，需要将原二维码中每个像素计算映射到标准二维码中，很耗时。后来考虑到反透视变换实际上只是计算出一个变换矩阵，而对于拍到二维码，只需要获得采样点的像素值即可，不需要将整个二维码中全部像素点都映射；所以只在需要某个采样点像素值时，将其标准化坐标通过透视变换矩阵转换为真实坐标，再获得像素值即可。
- 其他主要是Java语法层面优化，比如变量复用，减少`new`之类的。

#### 1.5.2. 代码扩展性差

问题：如有新的处理方法或新的二维码加入，需要修改代码时就有种牵一发而动全身的感觉，代码扩展性差。

解决方法：

- 恶补面向对象编程思想，设计模式。
- 充分利用继承和抽象复用代码，如不同形状二维码，不同颜色二维码。
- 使用工厂方法管理不同二维码的实例化，复用同一套处理框架。
- 使用策略模式根据不同需求调整使用不同的二维码定位算法。
- 将各种不同二维码的构造生成方法抽象为统一的平台，将二维码分割成border、padding、数据区等块，对于每一块独立指定二维码形状和数据等即可生成二维码。这样避免了为每种二维码写一个大同小异的生成方法，也避免了需要计算各种偏移量等。
