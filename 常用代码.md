# 设计模式

## 单例模式

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

# 排序

## 快速排序`partition`过程

### 方法一

```python
def partition(array, low, high):
    pivot = array[low]
    while low < high:
        while low < high and array[high] >= pivot:
            high -= 1
        array[low] = array[high]
        while low < high and array[low] <= pivot:
            low += 1
        array[high] = array[low]
    array[low] = pivot
    return low
```

### 方法二

```python
def partition2(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    pivot = array[high]
    current = low
    for i in range(low, high):
        if array[i] < pivot:
            swap(array, i, current)
            current += 1
    swap(array, high, current)
    return current
```

### 方法三

```python
def partition3(array, low, high):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    start = low
    pivot = array[low]
    low += 1
    while low <= high:
        while low <= high and array[low] <= pivot:
            low += 1
        while low <= high and array[high] >= pivot:
            high -= 1
        if low < high:
            swap(array, low, high)
    swap(array, start, high)
    return high
```

## 快速排序

### 递归

```python
def quick_sort(array, low, high):
    if low >= high:
        return
    mid = partition(array, low, high)
    quick_sort(array, low, mid - 1)
    quick_sort(array, mid + 1, high)
```

### 非递归

```python
def quick_sort(array, low, high):
    stack = []
    stack.append(low)
    stack.append(high)
    while stack:
        high = stack.pop()
        low = stack.pop()
        if low >= high:
            continue
        mid = partition(array, low, high)
        stack.append(low)
        stack.append(mid - 1)
        stack.append(mid + 1)
        stack.append(high)
```

## 插入排序

```python
def insertion_sort(array):
    for i in range(1, len(array)):
        temp = array[i]
        j = i - 1
        while j >= 0 and temp < array[j]:
            array[j + 1] = array[j]
            j -= 1
        array[j + 1] = temp
```

## 冒泡排序

```python
def bubble_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for j in range(len(array) - 1, 0, -1):
        flag = True
        for i in range(0, j):
            if array[i] > array[i + 1]:
                swap(array, i, i + 1)
                flag = False
        if flag:
            break
```

## 选择排序

```python
def selection_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    for i in range(0, len(array) - 1):
        min_index = i
        for j in range(i + 1, len(array)):
            if array[j] < array[min_index]:
                min_index = j
        swap(array, i, min_index)
```

## 归并排序

### 递归

```python
def merge(array, temp_array, low, mid, high):
    start1 = low
    end1 = mid
    start2 = mid
    end2 = high
    k = low
    while start1 < end1 and start2 < end2:
        if array[start1] < array[start2]:
            temp_array[k] = array[start1]
            start1 += 1
        else:
            temp_array[k] = array[start2]
            start2 += 1
        k += 1
    while start1 < end1:
        temp_array[k] = array[start1]
        start1 += 1
        k += 1
    while start2 < end2:
        temp_array[k] = array[start2]
        start2 += 1
        k += 1
    for k in range(low, high):
        array[k] = temp_array[k]


def merge_sort(array, temp_array, low, high):
    if low >= high:
        return
    mid = (low + high) // 2
    merge_sort(array, temp_array, low, mid)
    merge_sort(array, temp_array, mid + 1, high)
    merge(array, temp_array, low, mid, high)
```

### 非递归

```python
def merge_sort(array):
    length = len(array)
    temp_array = [0] * length
    block = 1
    while block < length * 2:
        for start in range(0, length, 2 * block):
            low = start
            mid = (start + block) if (start + block) < length else length
            high = (start + 2 * block) if (start + 2 * block) < length else length
            start1 = low
            end1 = mid
            start2 = mid
            end2 = high
            k = low
            while start1 < end1 and start2 < end2:
                if array[start1] < array[start2]:
                    temp_array[k] = array[start1]
                    start1 += 1
                else:
                    temp_array[k] = array[start2]
                    start2 += 1
                k += 1
            while start1 < end1:
                temp_array[k] = array[start1]
                start1 += 1
                k += 1
            while start2 < end2:
                temp_array[k] = array[start2]
                start2 += 1
                k += 1
        array, temp_array = temp_array, array
        block *= 2
```

## 堆排序

```python
def heap_sort(array):
    def swap(array, i, j):
        array[i], array[j] = array[j], array[i]

    def shift_down(start, end):
        root = start
        while True:
            child = 2 * root + 1
            if child > end:
                break
            if child + 1 <= end and array[child] < array[child + 1]:
                child += 1
            if array[root] < array[child]:
                swap(array, root, child)
                root = child
            else:
                break

    def build_heap(array):
        length = len(array)
        for start in range((length - 1) // 2, -1, -1):
            shift_down(start, length - 1)

    build_heap(array)
    for end in range(len(array) - 1, 0, -1):
        swap(array, 0, end)
        shift_down(0, end - 1)
```

# 链表

## 反转链表（头插法）

```python
def reverse_list(head):
    if not head:
        return head
    new_head = head
    while head.next:
        current = head.next
        head.next = head.next.next
        current.next = new_head
        new_head = current
    return new_head
```

# 二叉树遍历

## 二叉树前序遍历

### 递归

```python
def pre_order(root):
    if root:
        print(root.val)
        pre_order(root.left)
        pre_order(root.right)
```

### 非递归

```python
def pre_order(root):
    stack = []
    while root or stack:
        if root:
            print(root.val)
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            root = node.right
```

## 二叉树中序遍历

### 递归

```python
def in_order(root):
    if root:
        in_order(root.left)
        print(root.val)
        in_order(root.right)
```

### 非递归

```python
def in_order(root):
    stack = []
    while root or stack:
        if root:
            stack.append(root)
            root = root.left
        else:
            node = stack.pop()
            print(node.val)
            root = node.right
```

## 二叉树后序遍历

### 递归

```python
def post_order(root):
    if root:
        post_order(root.left)
        post_order(root.right)
        print(root.val)
```

### 非递归

```python
def post_order(root):
    stack = []
    result = []
    node = root
    while node or stack:
        if node:
            stack.append(node)
            result.append(node.val)
            node = node.right
        else:
            node = stack.pop()
            node = node.left
    result.reverse()
    return result
```

## 二叉树层次遍历

```python
def level_order(root):
    if not root:
        return
    queue = collections.deque()
    queue.append(root)
    while queue:
        size = len(queue)
        for i in range(size):
            node = queue.popleft()
            print(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
```

# 图

## Dijkstra算法

### 朴素

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    while candidates:
        min_d = sys.maxsize
        u = -1
        for candidate in candidates:
            if min_d > d[candidate]:
                min_d = d[candidate]
                u = candidate
        if u == end:
            return d[u], previous
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                previous[v] = u
```

### 堆优化

```python
def dijkstra(start, end, graph, n):
    """
    :param start: int, [1,n]
    :param end: int, [1,n]
    :param graph: dict, {from: (to, distance), from: (to, distance)...}
    :param n: int
    :return: (int, list), minimum distance, path
    """
    d = [sys.maxsize] * (n + 1)
    previous = [None] * (n + 1)
    d[start] = 0
    candidates = set(i for i in range(1, n + 1))
    heap = []
    heapq.heappush(heap, (0, start))
    while candidates:
        distance, u = heapq.heappop()
        if u == end:
            return d[u], previous
        if u not in candidates:
            continue
        candidates.remove(u)
        for v, dist in graph[u]:
            if d[v] > d[u] + dist:
                d[v] = d[u] + dist
                heapq.heappush(heap, (d[v], v))
                previous[v] = u
```

## Floyd-Warshall算法

```python
def floyd_warshall(graph, n):
    INF = 10000
    dist = [[INF] * n for _ in range(n)]
    path = [[-1] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0
            elif graph[i][j] < INF:
                dist[i][j] = graph[i][j]
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] > dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                    path[i][j] = k
    return dist, path
```

## 拓扑排序

### DFS

```python
def topological_sort(graph, n):
    order = []
    visiting = [False] * n
    visited = [False] * n
    for i in range(n):
        if not visited[i]:
            if not dfs(graph, i, visiting, visited, order):
                raise ValueError('cycle')
    order.reverse()
    return order


def dfs(graph, index, visiting, visited, order):
    visiting[index] = True
    visited[index] = True
    for neighbor in graph[index]:
        if visiting[neighbor]:
            return False
        if not visited[neighbor]:
            if not dfs(graph, neighbor, visiting, visited, order):
                return False
    order.append(index)
    visiting[index] = False
    return True
```

### BFS

```python
def topological_sort(graph, n):
    in_degrees = [0] * n
    for i in range(n):
        for index in graph[i]:
            in_degrees[index] += 1
    candidates = set()
    for i in range(n):
        if in_degrees[i] == 0:
            candidates.add(i)
    order = []
    while candidates:
        index = candidates.pop()
        order.append(index)
        for neighbor in graph[index]:
            in_degrees[neighbor] -= 1
            if in_degrees[neighbor] == 0:
                candidates.add(neighbor)
    if len(order) != n:
        raise ValueError('cycle')
    return order
```

# 查找

## 二分搜索

```python
def binary_search(array, key):
    low = 0
    high = len(array) - 1
    while low <= high:
        mid = (low + high) // 2
        if array[mid] == key:
            return mid
        elif array[mid] > key:
            high = mid - 1
        else:
            low = mid + 1
    return -1
```

## 并查集

```python
class UnionFind:
    def __init__(self, n):
        self.count = n
        self.parent = [i for i in range(n)]
        self.rank = [0] * n

    def find(self, num):
        if num != self.parent[num]:
            self.parent[num] = self.find(self.parent[num])
        return self.parent[num]

    def union(self, a, b):
        parent_a = self.find(a)
        parent_b = self.find(b)
        if parent_a == parent_b:
            return
        if self.rank[parent_a] > self.rank[parent_b]:
            self.parent[parent_b] = parent_a
        else:
            self.parent[parent_a] = parent_b
            if self.rank[parent_a] == self.rank[parent_b]:
                self.rank[parent_b] += 1
        self.count -= 1
```

## Trie树

```java
public class Trie {
    TrieNode root;

    class TrieNode {
        boolean isWord = false;
        char val;
        TrieNode[] children = new TrieNode[26];
    }

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                current.children[letter - 'a'] = new TrieNode();
                current.children[letter - 'a'].val = letter;
            }
            current = current.children[letter - 'a'];
        }
        current.isWord = true;
    }

    public boolean search(String word) {
        TrieNode current = root;
        for (char letter : word.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return current.isWord;
    }

    public boolean startsWith(String prefix) {
        TrieNode current = root;
        for (char letter : prefix.toCharArray()) {
            if (current.children[letter - 'a'] == null) {
                return false;
            }
            current = current.children[letter - 'a'];
        }
        return true;
    }
}
```

# 回溯

## N皇后问题

```python
def n_queens(n):
    """
    :type n: int
    :rtype: List[List[str]]
    """
    board = [['.'] * n for _ in range(n)]
    result = []
    back_trace(board, 0, result)
    return result


def back_trace(board, row_index, result):
    if row_index == len(board):
        result.append(convert(board))
        return
    for j in range(len(board[row_index])):
        if is_valid(board, row_index, j):
            board[row_index][j] = 'Q'
            back_trace(board, row_index + 1, result)
            board[row_index][j] = '.'


def convert(board):
    return [''.join(row) for row in board]


def is_valid(board, i, j):
    for x in range(i):
        for y in range(len(board[i])):
            if board[x][y] == 'Q' and (y == j or i - x == j - y or i - x == y - j):
                return False
    return True
```

# 栈与队列

## 栈模拟队列

```java
public class MyQueue {
    Stack<Integer> stackA;
    Stack<Integer> stackB;

    public MyQueue() {
        stackA = new Stack<>();
        stackB = new Stack<>();
    }

    public void push(int x) {
        stackA.add(x);
    }

    public int pop() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.pop();
    }

    public int peek() {
        if (stackB.empty()) {
            while (!stackA.empty()) {
                stackB.add(stackA.pop());
            }
        }
        return stackB.peek();
    }

    public boolean empty() {
        return stackA.empty() && stackB.empty();
    }
}
```

## 队列模拟栈

```java
public class MyStack {
    Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.add(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.add(queue.poll());
        }
    }

    public int pop() {
        return queue.poll();
    }

    public int top() {
        return queue.peek();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}
```

# 同步问题

## 生产者----消费者模型

```java
public class Main {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        int maxSize = 10;
        Thread producer1 = new Producer(queue, maxSize, "Producer 1");
        Thread producer2 = new Producer(queue, maxSize, "Producer 2");
        Thread consumer1 = new Consumer(queue, "Consumer 1");
        Thread consumer2 = new Consumer(queue, "Consumer 2");

        producer1.start();
        consumer1.start();
        producer2.start();
        consumer2.start();
    }

    static class Producer extends Thread {
        Queue<Integer> queue;
        int maxSize;
        Random random;

        public Producer(Queue<Integer> queue, int maxSize, String name) {
            super(name);
            this.queue = queue;
            this.maxSize = maxSize;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void produce() throws InterruptedException {
            synchronized (queue) {
                while (queue.size() == maxSize) {
                    System.out.println("Queue is full, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = random.nextInt();
                queue.add(item);
                System.out.println(this.getName() + " produced " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }

    static class Consumer extends Thread {
        Queue<Integer> queue;
        Random random;

        public Consumer(Queue<Integer> queue, String name) {
            super(name);
            this.queue = queue;
            random = new Random();
        }

        @Override
        public void run() {
            while (true) {
                try {
                    consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

        void consume() throws InterruptedException {
            synchronized (queue) {
                while (queue.isEmpty()) {
                    System.out.println("Queue is empty, " + this.getName() + " is waiting");
                    queue.wait();
                }
                int item = queue.remove();
                System.out.println(this.getName() + " consumed " + item + ", queue size is " + queue.size() + " now");
                queue.notifyAll();
                Thread.sleep(new Random().nextInt(1000));
            }
        }
    }
}
```

# 缓存策略

## LRU

```python
class LRUCache:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.val = value
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.capacity = capacity
        self.memory = {}
        self.head = self.Node(-1, -1)
        self.tail = self.Node(-1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory:
            return -1
        node = self.memory[key]
        self.to_head(node)
        return node.val

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if key in self.memory:
            node = self.memory[key]
            node.val = value
            self.to_head(node)
        else:
            if len(self.memory) == self.capacity:
                del self.memory[self.tail.prev.key]
                self.remove(self.tail.prev)
            node = self.Node(key, value)
            self.memory[key] = node
            self.add(node)

    def to_head(self, node):
        self.remove(node)
        self.add(node)

    def remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def add(self, node):
        node.next = self.head.next
        self.head.next = node
        node.prev = self.head
        node.next.prev = node
```

## LFU

```python
class LFUCache:
    class Node:
        def __init__(self, key, value, times):
            self.key = key
            self.value = value
            self.times = times
            self.prev = None
            self.next = None

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.init_capacity = capacity
        self.capacity = capacity
        self.memory_nodes = {}
        self.memory_times = {}
        self.head = self.Node(-1, -1, -1)
        self.tail = self.Node(-1, -1, -1)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key):
        """
        :type key: int
        :rtype: int
        """
        if key not in self.memory_nodes:
            return -1
        self.put(key, self.memory_nodes[key].value)
        return self.memory_nodes[key].value

    def put(self, key, value):
        """
        :type key: int
        :type value: int
        :rtype: void
        """
        if self.init_capacity == 0:
            return
        if key in self.memory_nodes:
            node = self.memory_nodes[key]
            node.value = value

            if node.times + 1 in self.memory_times:
                if self.memory_times[node.times] == node:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                node.prev.next = node.next
                node.next.prev = node.prev
                node.prev = self.memory_times[node.times + 1].prev
                node.next = self.memory_times[node.times + 1]
                node.next.prev = node
                node.prev.next = node
                self.memory_times[node.times + 1] = node
            else:
                if self.memory_times[node.times] != node:
                    node.prev.next = node.next
                    node.next.prev = node.prev
                    node.prev = self.memory_times[node.times].prev
                    node.next = self.memory_times[node.times]
                    node.next.prev = node
                    node.prev.next = node
                else:
                    if node.next.times == node.times:
                        self.memory_times[node.times] = node.next
                    else:
                        del self.memory_times[node.times]
                self.memory_times[node.times + 1] = node
            node.times += 1
        else:
            node = self.Node(key, value, 1)
            self.memory_nodes[key] = node
            if self.capacity == 0:
                node_to_remove = self.tail.prev
                if self.memory_times[node_to_remove.times] == node_to_remove:
                    del self.memory_times[node_to_remove.times]
                node_to_remove.prev.next = node_to_remove.next
                node_to_remove.next.prev = node_to_remove.prev
                del self.memory_nodes[node_to_remove.key]
                self.capacity += 1
            if 1 in self.memory_times:
                node.prev = self.memory_times[1].prev
                node.next = self.memory_times[1]

            else:
                node.prev = self.tail.prev
                node.next = self.tail
            node.next.prev = node
            node.prev.next = node
            self.memory_times[1] = node
            self.capacity -= 1
```

# 经典题目

## 计算数字二进制表示的1的个数

![Leetcode 461. Hamming Distance][leetcode_461]

```python
def count_1s(num):
    count = 0
    while num:
        num &= (num - 1)
        count += 1
    return count
```

## 数组中除一个数仅出现一次外，其他数均出现两次，找出这个数

![Leetcode 136. Single Number][leetcode_136]

```python
def single_number(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
```

## 长为n的数组中所有元素在[1, n]之间，元素最多出现两次，找出[1, n]中没出现的元素

![Leetcode 448. Find All Numbers Disappeared in an Array][leetcode_448]

```python
def find_disappeared_numbers(nums):
    """
    :type nums: List[int]
    :rtype: List[int]
    """
    for num in nums:
        index = num if num > 0 else -num
        index -= 1
        if nums[index] > 0:
            nums[index] = -nums[index]
    result = []
    for (index, num) in enumerate(nums):
        if num > 0:
            result.append(index + 1)
    return result
```

[leetcode_461]: https://leetcode.com/problems/hamming-distance/#/description

[leetcode_136]: https://leetcode.com/problems/single-number/#/description

[leetcode_448]: https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/#/description
